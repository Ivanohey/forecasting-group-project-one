## 4.5 Lichtenstein{.tabset}

```{r, warning=FALSE, echo=FALSE, results='hide'}
# Investigating Lichtenstein closely before 2008
Lichtenstein_before_2008 <- data_elec %>% select(Date,Lichtenstein) %>% filter(Date <= as.Date("2008-01-01"))

# Investigating Lichtenstein closely after 2008
Lichtenstein_after_2008 <- data_elec %>% select(Date,Lichtenstein) %>% filter(Date >= as.Date("2008-01-01"))

```

### Unit Root Test for Stationarity 

Investigating the stationarity for Lichtenstein is important since the bahavior of the time series was not In order to observe the stationarity assumption of Lichtenstein time serie. We have run the Unit Root Test which is a statistical test that checks for the presence of a unit root in a time series, which is an indication of non-stationarity.

Unit Root Test has the following hypothesis: 

$$H_0: The\ time\ series\ has\ a\ unit\ root\ (non\ stationary)\\ H_1: The\ time\ series\ is\ stationary$$

H0: The time series has a unit root (non-stationary).
H1: The time series is stationary.

```{r, warning=FALSE, echo=FALSE}
# Load the required package
library(tseries)

# Convert the data into a time series object
Lichtenstein_since_2010 <- data_elec %>% select(Date,Lichtenstein) %>% filter(Date >= as.Date("2010-01-01"))
ts_Lich <- ts(Lichtenstein_since_2010$Lichtenstein, frequency=12, start=c(2010,1))

# Check for linearity using ADF test
test_adf<- adf.test(ts_Lich)
```

In this case the Unit Root Test was performed on a the data Lichtenstein, and the test statistic was `test_adf$statistic`. The p-value of the test was 0.01 `test_adf$p.value,` which indicates strong evidence to reject the null hypothesis of non-stationarity at `\alpha = 0.05`. Thus Lichtenstein data is a stationary time serie.

Based on the previous analysis Lichtenstein data is stationary time series with high presence of trend and seasonality, thus we can consider using a simple ARIMA, ETS, S-naive and Piece-Wise.
- 
- 
- S-naive approach
- Piece-Wise ARIMA approach is useful when the time series exhibits different behaviors over different periods. Indeed, we can observe four knots which exhibits different pattern in 2008, 2009,2015,2016. We have selected those date as knots.

### **Testing Models**
Below is the plot of how well each model fits the data based on a 60-period prediction starting from 2016. The this code fits an different models to the training data, generates forecasts, and then applies a constraint to the forecasted mean values to ensure they are not negative.

```{r, warning=FALSE, echo=FALSE}
#Split the data
training_Licht <- data_elec %>% select(Date, Lichtenstein) %>%  filter(Date < as.Date("2016-01-01"))
test_Licht <- data_elec %>% select(Date, Lichtenstein) %>% filter(Date >= as.Date("2016-01-01"))


# Fit ARIMA model and generate forecasts
data_fit_Licht_a <- training_Licht %>%
  model(ARIMA(Lichtenstein))
forecasts_Licht_a <- data_fit_Licht_a %>%
  forecast(h = 60)


# Fit ETS model and generate forecasts
data_fit_Licht_e <- training_Licht %>%
  model(ETS(Lichtenstein))
forecasts_Licht_e <- data_fit_Licht_e %>%
  forecast(h = 60)
forecasts_Licht_e$.mean <- ifelse(forecasts_Licht_e$.mean < 0, 0, forecasts_Licht_e$.mean)

# Fit seasonal naive model and generate forecasts
data_fit_Licht_n <- training_Licht %>%
  model(SNAIVE(Lichtenstein))
forecasts_Licht_n <- data_fit_Licht_n %>%
  forecast(h = 60)
forecasts_Licht_n$.mean <- ifelse(forecasts_Licht_n$.mean < 0, 0, forecasts_Licht_n$.mean)


# Fit piece wise model and generate forecasts
data_fit_Licht_pw <- training_Licht %>%
  model(piecewise = ARIMA(Lichtenstein ~ trend(knots = c(2008, 2009,2015,2016))))
forecasts_Licht_pw <- data_fit_Licht_pw%>%
  forecast(h = 60)
forecasts_Licht_pw$.mean <- ifelse(forecasts_Licht_pw$.mean < 0, 0, forecasts_Licht_pw$.mean)


# Combine forecasts into a single data frame
all_forecasts_Licht <- bind_rows(
  data.frame(Date = forecasts_Licht_a$Date, Method = "ARIMA", Forecast = forecasts_Licht_a$.mean),
  data.frame(Date = forecasts_Licht_e$Date, Method = "ETS", Forecast = forecasts_Licht_e$.mean),
  data.frame(Date = forecasts_Licht_n$Date, Method = "SNAIVE", Forecast = forecasts_Licht_n$.mean),
  data.frame(Date = forecasts_Licht_pw$Date, Method = "PIECE WISE", Forecast = forecasts_Licht_pw$.mean))

# Plot all three sets of forecasts together
data_elec %>% autoplot(Lichtenstein) +
  geom_line(data = all_forecasts_Licht, aes(x = Date, y = Forecast, color = Method)) +
  labs(title = "Electricity Demand in Lichtenstein")

```

###**Measuring Model Accuracy**
A low AIC value is desirable as it indicates a better trade-off between model fit and complexity. Thus
```{r, warning=FALSE, echo=FALSE}
#Accuracy
Licht_accuracy_a <-data_fit_Licht_a %>%
  refit(test_Licht) %>%
  accuracy()

Licht_accuracy_e <-data_fit_Licht_e %>%
  refit(test_Licht) %>%
  accuracy()

Licht_accuracy_n <-data_fit_Licht_n %>%
  refit(test_Licht) %>%
  accuracy()

Licht_accuracy_pw <- data_fit_Licht_pw %>%
  refit(test_Licht) %>%
  accuracy()

Licht_accuracy_table <- rbind(
  data.frame(Licht_accuracy_a),
  data.frame(Licht_accuracy_e),
  data.frame(Licht_accuracy_n),
  data.frame(Licht_accuracy_pw))

#AIC
report(data_fit_Licht_a)
report(data_fit_Licht_e)
report(data_fit_Licht_n)
report(data_fit_Licht_pw)

```

```{r, warning=FALSE, echo=FALSE}
Licht_accuracy_table[ 1:4,1:10] %>%
  kbl() %>%
  kable_paper(full_width = F) %>%
  column_spec(4, color = "white",
              background = spec_color(Licht_accuracy_table$RMSE[1:4],end = 0.7))
```

### **Residuals**
Interesting to examine any outliers or extreme values in the residuals.
```{r, warning=FALSE, echo=FALSE}
gg_tsresiduals(data_fit_Licht_a) + labs(title = "ARIMA Lichtenstein residuals analysis")

gg_tsresiduals(data_fit_Licht_e) + labs(title = "ETS Lichtenstein residuals analysis")

gg_tsresiduals(data_fit_Licht_n) + labs(title = "SNAIVE Lichtenstein residuals analysis")

gg_tsresiduals(data_fit_Licht_pw) + labs(title = "PIECE WISE Lichtenstein residuals analysis")
```
