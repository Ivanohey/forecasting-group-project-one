## 4.5 Lichtenstein{.tabset}

```{r, warning=FALSE, echo=FALSE, results='hide'}
# Investigating Lichtenstein closely before 2008
Lichtenstein_before_2008 <- data_elec %>% select(Date,Lichtenstein) %>% filter(Date <= as.Date("2008-01-01"))

# Investigating Lichtenstein closely after 2008
Lichtenstein_after_2008 <- data_elec %>% select(Date,Lichtenstein) %>% filter(Date >= as.Date("2008-01-01"))

```


### **Testing Models**
Below is the plot of how well each model fits the data based on a 60-period prediction starting from 2016. This code fits different models to the training data, generates forecasts, and then applies a constraint to the forecasted mean values to ensure they are not negative.
Based on the previous analysis Lichtenstein data is stationary time series with high presence of trend and seasonality, thus we can consider using following models to perform our analysis: simple ARIMA, ETS, S-naive and Piece-Wise. A Piece-Wise ARIMA approach could be useful when the ts shows different behaviors over different periods. Indeed, we can observe four knots which exhibits different pattern in 2008, 2009,2015 and 2016. We have selected those date as knots and will observe the result.

```{r, warning=FALSE, echo=FALSE}
#Split the data
training_Licht <- data_elec %>% select(Date, Lichtenstein) %>%  filter(Date < as.Date("2016-01-01"))
test_Licht <- data_elec %>% select(Date, Lichtenstein) %>% filter(Date >= as.Date("2016-01-01"))


# Fit ARIMA model and generate forecasts
data_fit_Licht_a <- training_Licht %>%
  model(ARIMA(Lichtenstein))
forecasts_Licht_a <- data_fit_Licht_a %>%
  forecast(h = 60)


# Fit ETS model and generate forecasts
data_fit_Licht_e <- training_Licht %>%
  model(ETS(Lichtenstein))
forecasts_Licht_e <- data_fit_Licht_e %>%
  forecast(h = 60)
forecasts_Licht_e$.mean <- ifelse(forecasts_Licht_e$.mean < 0, 0, forecasts_Licht_e$.mean)

# Fit seasonal naive model and generate forecasts
data_fit_Licht_n <- training_Licht %>%
  model(SNAIVE(Lichtenstein))
forecasts_Licht_n <- data_fit_Licht_n %>%
  forecast(h = 60)
forecasts_Licht_n$.mean <- ifelse(forecasts_Licht_n$.mean < 0, 0, forecasts_Licht_n$.mean)


# Fit piece wise ARIMA model and generate forecasts
data_fit_Licht_pw_a <- training_Licht %>%
  model(piecewise = ARIMA(Lichtenstein ~ trend(knots = c(2008, 2009,2015,2016))))
forecasts_Licht_pw_a <- data_fit_Licht_pw_a%>%
  forecast(h = 60)
forecasts_Licht_pw_a$.mean <- ifelse(forecasts_Licht_pw_a$.mean < 0, 0, forecasts_Licht_pw_a$.mean)


# Combine forecasts into a single data frame
all_forecasts_Licht <- bind_rows(
  data.frame(Date = forecasts_Licht_a$Date, Method = "ARIMA", Forecast = forecasts_Licht_a$.mean),
  data.frame(Date = forecasts_Licht_e$Date, Method = "ETS", Forecast = forecasts_Licht_e$.mean),
  data.frame(Date = forecasts_Licht_n$Date, Method = "SNAIVE", Forecast = forecasts_Licht_n$.mean),
  data.frame(Date = forecasts_Licht_pw_a$Date, Method = "Piece Wise ARIMA", Forecast = forecasts_Licht_pw_a$.mean))

# Plot all three sets of forecasts together
data_elec %>% autoplot(Lichtenstein) +
  geom_line(data = all_forecasts_Licht, aes(x = Date, y = Forecast, color = Method)) +
  labs(title = "Electricity Demand in Lichtenstein")

```

### **Measuring Model Accuracy**
In our case S-Naive outperform during the model selection and analysis of accuracy. However S-Naive method may perform well for the time period that we have train our data, but it is important to note that it has some limitations. Indeed, it assumes that historical patterns will repeat exactly in the future, which may not always hold. The S-Naive method may not account for underlying factors or trends that could impact future outcomes. Therefore, there is an increased risk of inaccurate forecasts if the method is blindly applied without considering other relevant factors.
Thus we've selected ETS based on a trade off between forecasting error and complexity of the model. ETS model has the third lowest RMSE and second lowest MAE which makes him a good candidate. 

```{r, warning=FALSE, echo=FALSE}
#Accuracy
Licht_accuracy_a <- accuracy(forecasts_Licht_a, test_Licht)

Licht_accuracy_e <-accuracy(forecasts_Licht_e, test_Licht)

Licht_accuracy_n <-accuracy(forecasts_Licht_n, test_Licht)

Licht_accuracy_pw_a <- accuracy(forecasts_Licht_pw_a, test_Licht)

Licht_accuracy_table <- rbind(
  data.frame(Licht_accuracy_a),
  data.frame(Licht_accuracy_e),
  data.frame(Licht_accuracy_n),
  data.frame(Licht_accuracy_pw_a))
#AIC
#report(data_fit_Licht_a)
#report(data_fit_Licht_pw_a)
```

```{r, warning=FALSE, echo=FALSE}
Licht_accuracy_table[ 1:4,1:10] %>%
  kbl() %>%
  kable_paper(full_width = F) %>%
  column_spec(4, color = "white",
              background = spec_color(Licht_accuracy_table$RMSE[1:4],end = 0.7))
```
```{r}
report(data_fit_Licht_e)
#report(data_fit_Licht_n)
```

### **Residuals**
It is interesting to examine any outliers or extreme values in the residuals. The ACF analysis for ETS model shows that there's no correlation between the ts and its lagged values. Thus, each observation in the ts can be considered unrelated to the previous values. It suggests that there is no structure in the data that can be exploited for forecasting. Consequently, Lichtenstein ts might need covariate to forecast and analyse it adequately. Concerning the residual, it should ideally appear random, in our case residuals are chinked around zero, thus those might shows autocorrelation.

```{r, warning=FALSE, echo=FALSE}
#gg_tsresiduals(data_fit_Licht_a) + labs(title = "ARIMA Lichtenstein residuals analysis")

gg_tsresiduals(data_fit_Licht_e) + labs(title = "ETS Lichtenstein residuals analysis")

#gg_tsresiduals(data_fit_Licht_n) + labs(title = "SNAIVE Lichtenstein residuals analysis")

#gg_tsresiduals(data_fit_Licht_pw_a) + labs(title = "PIECE WISE Lichtenstein residuals analysis")
```
