## Lichtenstein

- ETS creates a negative value forecast, I will just set the negative forecast values to 0.
- Maybe should find a better way to use ETS (by not allowing it to drop below 0) or just use other models

We have selected S-naive,S-ARIMA In general, S-ARIMA is more suitable for complex time series with trends, seasonality, and other patterns, while S-naive is simpler and more appropriate for time series with stable and predictable seasonal patterns.

```{r}
data_elec %>% autoplot(Lichtenstein) + 
  ggtitle("Exports from Switzerland to Lichtenstein") +
  ylab("GWt") + xlab("Month")
```
```{r}
# Investigating Lichtenstein closely before 2008
Lichtenstein_before_2008 <- data_elec %>% 
  select(Date,Lichtenstein) %>% 
  filter(Date <= as.Date("2008-01-01"))

autoplot(Lichtenstein_before_2008)
```

**Comment**
```{r}
# Investigating Lichtenstein closely after 2008
Lichtenstein_after_2008 <- data_elec %>% 
  select(Date,Lichtenstein) %>% 
  filter(Date >= as.Date("2008-01-01"))

autoplot(Lichtenstein_after_2008)
```
**Comment**

### Check the Stationarity by using Unit Root Test

```{r}
# Load the required package
library(tseries)

# Convert the data into a time series object
Lichtenstein_since_2010 <- data_elec %>% select(Date,Lichtenstein) %>% filter(Date >= as.Date("2010-01-01"))
ts_Lich <- ts(Lichtenstein_since_2010$Lichtenstein, frequency=12, start=c(2010,1))

# Check for linearity using ADF test
adf.test(ts_Lich)
```
```{r}
Lichtenstein_since_2010 %>% features(Lichtenstein_since_2010, unitroot_kpss)
```
In order to observe the stationarity assumption of Lichtenstein time serie. We have run the Unit Root Test which is a statistical test that checks for the presence of a unit root in a time series, which is an indication of non-stationarity.

Unit Root Test has the following hypothesis: 
$$H_0:$$ Data is stationary

$$H_a:$$ Data is non-stationary

In this case the Unit Root Test was performed on a the data Lichtenstein, and the test statistic was 3.20. The p-value of the test was 0.01 which indicates strong evidence to reject the null hypothesis of stationarity. Thus Lichtenstein time serie is non-stationary.

Based on it, we can use methods that assume non-stationarity, such as Random Walk Model, Autoregressive Integrated Moving Average (ARIMA), Exponential smoothing methods, Moving average models, Vector autoregression(VAR), ARIMA,SARIMA.

### Autocorrelation (ACF) and Partial autocorrelation function (PACF)

It's interesting to observe the autocorrelation to assess the correlation between a time series and its past values at different lags. ACF values range between -1 and 1, with 1 indicating a perfect positive correlation, 0 indicating no correlation, and -1 indicating a perfect negative correlation. In the other hand the Partial Autocorrelation Function (PACF) is similar to the ACF, it's is useful in identifying the specific lags that have a direct influence on the current observation. PACF values range also between -1 and 1.
```{r}
acf(ts_Lich, main = "Autocorrelation Function")
pacf(ts_Lich, main = "Partial Autocorrelation Function")
```
In this case both ACF and PACF indicating a tendency to have no correlation since the result is closer to 0. Thus there is a strong correlation between the the time series and its past values at the first 2 lags.

**Check if I keep** Furthermore, these functions are useful to observe presence of trend and seasonality. Indeed, A strong positive correlation on lags in the autocorrelation plot suggests the presence of a trend, while a strong correlation at seasonal lags in the partial autocorrelation plot suggests the presence of seasonality. In our case the presence of trend is high and the presence of seasonality around 0.4

### Model selection
Based on the previous analysis Lichtenstein data is stationary time series with high presence of trend and seasonality, thus we can consider using a simple ARIMA, Piece-Wise and . S-naive.

```{r}

#Split the data
training_lich <- Lichtenstein_after_2008 %>% select(Date,Lichtenstein) %>%  filter(Date < as.Date("2015-01-01"))
test_lich <- Lichtenstein_after_2008 %>% select(Date,Lichtenstein) %>% filter(Date >= as.Date("2015-01-01"))

# Fit ARIMA model and generate forecasts
data_fit_lich_arima <- training_lich %>%
  model(ARIMA(Lichtenstein))
forecasts_lich_arima <- data_fit_lich_arima %>%
  forecast(h = 140)

# Fit seasonal naive model and generate forecasts
data_fit_lich_naive <- training_lich %>%
  model(SNAIVE(Lichtenstein))
forecasts_Lich_naive <- data_fit_lich_naive %>%
  forecast(h = 140)


# Combine forecasts into a single data frame
all_forecasts_Lich <- bind_rows(
  data.frame(Date = forecasts_lich_arima$Date, Method = "ARIMA", Forecast = forecasts_lich_arima$.mean),
  data.frame(Date = forecasts_Lich_naive$Date, Method = "SNAIVE", Forecast = forecasts_Lich_naive$.mean))

# Plot all three sets of forecasts together
data_elec %>% autoplot(Lichtenstein)  +
  geom_line(data = all_forecasts_Lich, aes(x = Date, y = Forecast, color = Method)) +
  labs(title = "Electricity Consumption in Lichtenstein after 2008")

```

### Piece-wise ARIMA
```{r}
library(forecast)

# Subset the data by price-wise
Lich_list <- split(Lichtenstein_since_2010, Lichtenstein_since_2010$Lichtenstein)

# Loop through each price-wise subset
for (i in seq_along(Lich_list)) {
  # Subset the data for each price-wise group
  data_subset <- Lich_list[[i]]
  
  # Convert the data to a time series
  ts_data <- ts(data_subset$Lichtenstein, frequency = 12)
  
  # Fit a forecast model using auto.arima
  model <- auto.arima(ts_data)
  
  # Generate a forecast for the next 12 months
  forecast_data <- forecast(model, h = 12)
  
  # Plot the forecast
  plot(forecast_data, main = paste("Price-wise Forecast for", names(Lich_list)[i]))
}
```
### ARIMA model




### ETS Model (thank you but not usefull anymore)

Visualizing Lichtenstein again -> clearly need to use piecewise around 2019

```{r}
data_elec %>% autoplot(Lichtenstein) + 
  ggtitle("Exports from Switzerland to Lichtenstein") +
  ylab("GWt") + xlab("Month")
```

As a remember: Lichtenstein: Big drop in level of exports during 2008-2009. used to have a high export and drop to a certain level approximately 0-10 (exception 2015): 
- Lichtenstein: This country shows the opposite trend, with a very smooth peak in the coldest winter months (Jan,Feb), and the lowest energy exports during the summer months. 

```{r}
#Investigating Lichtenstein closely since 2010, because it seems like something changed -> perhaps should use Piecewise!!!
autoplot(Lichtenstein_since_2010)

#Modelling ets automatically
ets_lichtenstein <- data_elec %>%
  select(Lichtenstein) %>%
  model(ETS(Lichtenstein))

#Getting the Accuracy scores for models
report(ets_lichtenstein)

#Forecasting using the models
forecast_ets_lichtenstein<- ets_lichtenstein %>% forecast(h = 13)

#Graphing the forecast
ets_lichtenstein %>% forecast(h = 13) %>% autoplot(Lichtenstein_since_2010)+
  labs(title = "ETS ANA Forecast for Lichtenstein")

#Extracting the forecasted values

forecast_table_lichtenstein <- data.frame(Model = c("ETS (ANA)"),
                              Forecast_Values = c(forecast_ets_lichtenstein))

forecast_table_lichtenstein <- forecast_table_lichtenstein %>% select(Forecast_Values..mean)

colnames(forecast_table_lichtenstein)[1] <- "Lichtenstein_ets_ANA"

# replace negative values with 0
forecast_table_lichtenstein[forecast_table_lichtenstein < 0] <- 0


#components(ets_lichtenstein) %>% autoplot()
```

Since we can't have negative values, I decided to just set the negative ones to 0. 

This forecast actually doesn't look great. I would expect the next upward bounce to be of similar amplitude as the previous ones, but it seems like the forecast of the next bounce is only half the amplitude of the previous ones. 
